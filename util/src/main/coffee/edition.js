// Generated by CoffeeScript 1.6.3
(function() {
  var Citation2tag, Edition;

  Citation2tag = {
    article: ['div', 'type'],
    section: ['milestone', 'unit'],
    chapter: ['milestone', 'unit'],
    page: ['milestone', 'unit'],
    book: ['div', 'type'],
    text: ['text'],
    line: ['l'],
    scene: ['div', 'type'],
    act: ['div', 'type'],
    entry: ['div', 'type'],
    card: ['milestone', 'unit'],
    speech: ['div', 'type'],
    root: ['div', 'type'],
    poem: ['div', 'type']
  };

  Edition = (function() {
    var annotate, parents, selectPassage, wrap;

    function Edition(citationScheme, passageSelector, annotator, text) {
      this.citationScheme = citationScheme;
      this.passageSelector = passageSelector;
      this.annotator = annotator;
      this.text = text;
      this.text = this.text.get('/TEI.2/text');
      annotate(this.text, this.annotator);
      this.passage = selectPassage(this.citationScheme, this.passageSelector, this.text);
      this.parents = parents(this.passage);
    }

    Edition.prototype.find = function(path) {
      console.log("here");
      return wrap(this.text, this.passage, this.parents).find(path);
    };

    annotate = function(text, annotator) {
      var annotation, annotationNode, childNode, cursor, node, stack, _results;
      stack = [this.text];
      _results = [];
      while (node = stack.pop()) {
        _results.push((function() {
          var _i, _j, _len, _len1, _ref, _ref1, _results1;
          _ref = node.childNodes;
          _results1 = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            childNode = _ref[_i];
            cursor = childNode;
            if (childNode.name() === 'text') {
              _ref1 = annotator.annotate(childNode.text());
              for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                annotation = _ref1[_j];
                annotationNode = childNode.node('annotation', annotation.form);
                annotationNode.attr(annotation);
                cursor.addNextSibling(annotationNode);
              }
              _results1.push(childNode.remove());
            } else {
              _results1.push(stack.push(childNode));
            }
          }
          return _results1;
        })());
      }
      return _results;
    };

    selectPassage = function(citationScheme, passageSelector, text) {
      var attr, citation, i, label, passage, passageSelectorParts, tag, xpath, _i, _len, _ref;
      if (!passageSelector) {
        return text;
      }
      passageSelectorParts = passageSelector.split('.');
      passage = text;
      for (i = _i = 0, _len = citationScheme.length; _i < _len; i = ++_i) {
        citation = citationScheme[i];
        if (i > passageSelectorParts.length - 1) {
          break;
        }
        _ref = Citation2tag[label = citation.label], tag = _ref[0], attr = _ref[1];
        xpath = ".//" + tag;
        xpath += "[" + (attr ? "@" + attr + "='" + label + "' and " : '') + ("@n='" + passageSelectorParts[i] + "']");
        console.log("bitch");
        passage = passage.get(xpath);
        console.log(2);
        if (!passage) {
          return;
        }
      }
      console.log("selected");
      return passage;
    };

    parents = function(passage) {
      var node;
      parents = new Set;
      node = passage;
      parents.add(node);
      while (node.parent && (node = node.parent())) {
        parents.add(node);
      }
      return parents;
    };

    wrap = function(node, passage, parents) {
      return {
        find: function(path) {
          var found, _i, _len, _ref, _results;
          _ref = passage.find(path);
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            found = _ref[_i];
            if (parents.has(found)) {
              if (found === passage) {
                _results.push(passage);
              } else {
                _results.push(wrap(found, passage, parents));
              }
            }
          }
          return _results;
        },
        attr: function(name) {
          return node.attr(name);
        },
        text: function() {
          return node.text();
        },
        path: function() {
          return node.path();
        }
      };
    };

    return Edition;

  })();

  module.exports = Edition;

}).call(this);
